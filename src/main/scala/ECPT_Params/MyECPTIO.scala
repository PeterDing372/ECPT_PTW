package ECPT.Params

import chisel3._
import chipsalliance.rocketchip.config._
import chisel3.util._
import freechips.rocketchip.rocket._


/** PTE request from TLB to PTW
  *
  * TLB send a PTE request to PTW when L1TLB miss
  */
class MyPTWReq(implicit p: Parameters) extends MyCoreBundle()(p) {
  val addr = UInt(vpnBits.W)
  val need_gpa = Bool()
  val vstage1 = Bool()
  val stage2 = Bool()
}

/** PTE info from L2TLB to TLB
  *
  * containing: target PTE, exceptions, two-satge tanslation info
  */
class MyPTWResp(implicit p: Parameters) extends MyCoreBundle()(p) {
  /** ptw access exception */
  val ae_ptw = Bool()
  /** final access exception */
  val ae_final = Bool()
  /** page fault */
  val pf = Bool()
  /** guest page fault */
  val gf = Bool()
  /** hypervisor read */
  val hr = Bool()
  /** hypervisor write */
  val hw = Bool()
  /** hypervisor execute */
  val hx = Bool()
  /** PTE to refill L1TLB
    *
    * source: L2TLB
    */
  val pte = new PTE
  /** pte pglevel */
  val level = UInt(log2Ceil(pgLevels).W)
  /** fragmented_superpage support */
  val fragmented_superpage = Bool()
  /** homogeneous for both pma and pmp  */
  val homogeneous = Bool()
  val gpa = Valid(UInt(vaddrBits.W))
  val gpa_is_pte = Bool()
}

/** Datapath IO between PTW and Core
  *
  * PTW receives CSRs info, pmp checks, sfence instruction info
  *
  * PTW sends its performance statistics to core
  */
class MyDatapathPTWIO(implicit p: Parameters) extends MyCoreBundle()(p)
    with MyHasCoreParameters {
  val ptbr = Input(new MyPTBR())
  val hgatp = Input(new MyPTBR())
  val vsatp = Input(new MyPTBR())
  val sfence = Flipped(Valid(new MySFenceReq))
  val status = Input(new MStatus())
  val hstatus = Input(new HStatus())
  val gstatus = Input(new MStatus())
  // val pmp = Input(Vec(nPMPs, new PMP))
  val perf = Output(new PTWPerfEvents())
  val customCSRs = Input(coreParams.customCSRs)
  /** enable clock generated by ptw */
  val clock_enabled = Output(Bool())
}

// /** PTE template for transmission
//   *
//   * contains useful methods to check PTE attributes
//   * @see RV-priv spec 4.3.1 for pgae table entry format
//   */
/* @note this is Shadowing */
// class PTE(implicit p: Parameters) extends MyCoreBundle()(p) {
//   val reserved_for_future = UInt(10.W)
//   val ppn = UInt(44.W)
//   val reserved_for_software = Bits(2.W)
//   /** dirty bit */
//   val d = Bool()
//   /** access bit */
//   val a = Bool()
//   /** global mapping */
//   val g = Bool()
//   /** user mode accessible */
//   val u = Bool()
//   /** whether the page is executable */
//   val x = Bool()
//   /** whether the page is writable */
//   val w = Bool()
//   /** whether the page is readable */
//   val r = Bool()
//   /** valid bit */
//   val v = Bool()
//   /** return true if find a pointer to next level page table */
//   def table(dummy: Int = 0) = v && !r && !w && !x && !d && !a && !u && reserved_for_future === 0.U
//   /** return true if find a leaf PTE */
//   def leaf(dummy: Int = 0) = v && (r || (x && !w)) && a
//   /** user read */
//   def ur(dummy: Int = 0) = sr() && u
//   /** user write*/
//   def uw(dummy: Int = 0) = sw() && u
//   /** user execute */
//   def ux(dummy: Int = 0) = sx() && u
//   /** supervisor read */
//   def sr(dummy: Int = 0) = leaf() && r
//   /** supervisor write */
//   def sw(dummy: Int = 0) = leaf() && w && d
//   /** supervisor execute */
//   def sx(dummy: Int = 0) = leaf() && x
//   /** full permission: writable and executable in user mode */
//   def isFullPerm(dummy: Int = 0) = uw() && ux()
// }

/** L2TLB PTE template
  *
  * contains tag bits
  * @param nSets number of sets in L2TLB
  * @see RV-priv spec 4.3.1 for page table entry format
  */
class MyL2TLBEntry(nSets: Int)(implicit p: Parameters) extends MyCoreBundle()(p)
    with MyHasCoreParameters {
  val idxBits = log2Ceil(nSets)
  val tagBits = maxSVAddrBits - pgIdxBits - idxBits + (if (usingHypervisor) 1 else 0)
  val tag = UInt(tagBits.W)
  val ppn = UInt(ppnBits.W)
  /** dirty bit */
  val d = Bool()
  /** access bit */
  val a = Bool()
  /** user mode accessible */
  val u = Bool()
  /** whether the page is executable */
  val x = Bool()
  /** whether the page is writable */
  val w = Bool()
  /** whether the page is readable */
  val r = Bool()

}

class MyTLBPTWIO(implicit p: Parameters) extends MyCoreBundle()(p)
    with MyHasCoreParameters {
  val req = Decoupled(Valid(new MyPTWReq))
  val resp = Flipped(Valid(new MyPTWResp))
  // val resp = Valid(new MyPTWResp).flip
  val ptbr = Input(new MyPTBR())
  val hgatp = Input(new MyPTBR())
  val vsatp = Input(new MyPTBR())
  val status = Input(new MStatus())
  val hstatus = Input(new HStatus())
  val gstatus = Input(new MStatus())
  // val pmp = Input(Vec(nPMPs, new PMP))
  val customCSRs = Input(coreParams.customCSRs)
}